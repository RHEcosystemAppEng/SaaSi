apiVersion: v1
kind: SaasiDeployer
metadata:
  # Unique at cluster/NS scope
  name: example
  # TODO: shoud this  be constrained to be in the same NS as the Saasi operator?
  namespace: saasi-ns
  # Generated by the system
  uuid: UUID
spec:
  # Can deploy one cluster and one application for each request
  cluster:
    # Must match the clusterId of one of the exported clusters
    fromClusterId: SOURCE_CLUSTER_ID
    # Must be unique
    clusterId: TARGET_CLUSTER_ID
    # TODO: use Vault to store this sensitive data
    aws:
      aws_public_domain: <PUBLIC_DOMAIN_ROUTE53_SERVICE>
      aws_account_name: <ACCOUNT_NAME>
      aws_access_key_id: <SA_ACCESS_KEY>
      aws_secret_access_key: <SA_SECRET_ACCESS_KEY>
    params:
      # All are optional
      - name: CLUSTER_NAME
        value: ABCDEFG
      - name: CLUSTER_BASE_DOMAIN
        value: ABCDEFG
      - name: WORKER_COUNT
        value: NNN
  application:
    # Must match the name of one of the exported applications
    fromApplication: SOURCE_NAME
    # Must match the name of one of the exported applications
    name: TARGET_NAME
    # Optional, if omitted it will use the per-namespace mapping or, if missing, the original namespace
    namespaceMappingFormat: "%s-prod"
    namespaces:
    - name: NS1
      target: NEW-NS1
      # Actual values of all mandatory and selected optional parameters to override
      params:
      - configMap: MAP-1
        params:
        - name: PARAM-1
          value: VALUE-1
        - name: "..."
          value: "..."
      - configMap: MAP-2
        params:
        - name: PARAM-1
          value: VALUE-1
        - name: "..."
          value: "..."
      # Actual values of all secret parameters to define
      # TODO: use Vault to store this sensitive data
      secrets:
      - secret: SECRET-1
        params:
        - name: PARAM-1
          value: VALUE-1
        - name: "..."
          value: "..."
      - secret: SECRET-2
        params:
        - name: PARAM-1
          value: VALUE-1
        - name: "..."
          value: "..."
status:
  # History provides a report of the deploy status for each request
  history:
    cluster:
    - clusterId: TARGET_CLUSTER_ID
      # One of SCHEDULED, RUNNING, COMPLETED, FAILED
      state: SCHEDULED
      timestamp: t0
    - clusterId: TARGET_CLUSTER_ID
      state: RUNNING
      timestamp: t1
    - clusterId: TARGET_CLUSTER_ID
      state: COMPLETED
      timestamp: t2
      # Output contains configuration files like kubeconfig
      location: deployer/clusters/TARGET_CLUSTER_ID
    - clusterId: CLUSTERID-2
      state: SCHEDULED
      timestamp: t0
    - clusterId: CLUSTERID-2
      state: FAILED
      timestamp: t1
      errorMessage: "Authentication error"
      location: deployer/clusters/TARGET_CLUSTER_ID
    applications:
    - clusterId: APP
      # One of SCHEDULED, RUNNING, COMPLETED, FAILED
      state: SCHEDULED
      timestamp: t0
    - clusterId: APP
      state: RUNNING
      timestamp: t1
    - clusterId: APP
      state: COMPLETED
      timestamp: t2
      # Output contains configuration files like kubeconfig
      location: deployer/applications/APP
    - clusterId: APP-2
      state: SCHEDULED
      timestamp: t0
    - clusterId: APP-2
      state: FAILED
      timestamp: t1
      # Output contains configuration files like kubeconfig
      errorMessage: "Namespace NS1 not found"
      # Output folder contains error logs
      location: deployer/applications/APP